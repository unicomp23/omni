<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     width="100%" height="100%" viewBox="0 0 1400 800" 
     style="background: #1a1a1a; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
  
  <defs>
    <style>
      .control-btn {
        fill: #2d2d2d;
        stroke: #4a4a4a;
        stroke-width: 1;
        cursor: pointer;
        transition: fill 0.2s;
      }
      .control-btn:hover {
        fill: #3d3d3d;
      }
      .control-btn.active {
        fill: #4a9eff;
        stroke: #5aafff;
      }
      .axis-text {
        fill: #9a9a9a;
        font-size: 11px;
      }
      .title-text {
        fill: #e0e0e0;
        font-size: 18px;
        font-weight: 600;
      }
      .label-text {
        fill: #b0b0b0;
        font-size: 12px;
      }
      .grid-line {
        stroke: #333;
        stroke-width: 0.5;
        stroke-dasharray: 2,2;
      }
      .tooltip {
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.2s;
      }
      .tooltip-bg {
        fill: #2a2a2a;
        stroke: #4a4a4a;
        stroke-width: 1;
        filter: drop-shadow(0 2px 4px rgba(0,0,0,0.5));
      }
      .tooltip-text {
        fill: #e0e0e0;
        font-size: 11px;
        font-family: 'Courier New', monospace;
      }
      .file-input-label {
        fill: #4a9eff;
        cursor: pointer;
        font-size: 14px;
        text-decoration: underline;
      }
      .file-input-label:hover {
        fill: #6ab4ff;
      }
      .scroll-track {
        fill: #2d2d2d;
        stroke: #4a4a4a;
        stroke-width: 1;
      }
      .scroll-thumb {
        fill: #5a5a5a;
        cursor: grab;
        transition: fill 0.2s;
      }
      .scroll-thumb:hover {
        fill: #6a6a6a;
      }
      .scroll-thumb:active {
        cursor: grabbing;
        fill: #7a7a7a;
      }
    </style>
    
    <linearGradient id="gridGradient" x1="0%" y1="0%" x2="0%" y2="100%">
      <stop offset="0%" style="stop-color:#333;stop-opacity:0.5" />
      <stop offset="100%" style="stop-color:#333;stop-opacity:0.1" />
    </linearGradient>
  </defs>

  <!-- Title and Controls -->
  <text x="700" y="30" class="title-text" text-anchor="middle">Latency Percentile Viewer</text>
  
  <!-- File Input Control -->
  <g id="fileInputGroup" transform="translate(50, 50)">
    <text class="label-text" x="0" y="0">Data File:</text>
    <text class="file-input-label" x="70" y="0" id="fileLabel">Click to load bucket_analysis.jsonl</text>
  </g>
  
  <!-- Bucket Type Selector -->
  <g id="bucketSelector" transform="translate(50, 80)" style="display: none;">
    <text class="label-text" x="0" y="0">Bucket Type:</text>
    <g id="bucketButtons" transform="translate(90, -10)">
      <!-- Bucket type buttons will be dynamically created here -->
    </g>
  </g>
  
  <!-- Legend -->
  <g id="legend" transform="translate(1200, 80)" style="display: none;">
    <text class="label-text" x="0" y="0">Percentiles:</text>
    <g transform="translate(0, 15)">
      <line x1="0" y1="0" x2="20" y2="0" stroke="#ff6b6b" stroke-width="2"/>
      <text x="25" y="4" class="axis-text">p50</text>
    </g>
    <g transform="translate(0, 30)">
      <line x1="0" y1="0" x2="20" y2="0" stroke="#ffd93d" stroke-width="2"/>
      <text x="25" y="4" class="axis-text">p90</text>
    </g>
    <g transform="translate(0, 45)">
      <line x1="0" y1="0" x2="20" y2="0" stroke="#6bcf7f" stroke-width="2"/>
      <text x="25" y="4" class="axis-text">p95</text>
    </g>
    <g transform="translate(0, 60)">
      <line x1="0" y1="0" x2="20" y2="0" stroke="#4a9eff" stroke-width="2"/>
      <text x="25" y="4" class="axis-text">p99</text>
    </g>
    <g transform="translate(0, 75)">
      <line x1="0" y1="0" x2="20" y2="0" stroke="#c77dff" stroke-width="2"/>
      <text x="25" y="4" class="axis-text">p99.9</text>
    </g>
    <g transform="translate(0, 90)">
      <line x1="0" y1="0" x2="20" y2="0" stroke="#ff006e" stroke-width="2"/>
      <text x="25" y="4" class="axis-text">p99.99</text>
    </g>
  </g>
  
  <!-- Main Chart Area -->
  <g id="chartArea" transform="translate(80, 150)">
    <!-- Grid -->
    <g id="gridLines"></g>
    
    <!-- Axes -->
    <g id="xAxis"></g>
    <g id="yAxis"></g>
    
    <!-- Chart viewport with clipping -->
    <defs>
      <clipPath id="chartClip">
        <rect x="0" y="0" width="1200" height="500"/>
      </clipPath>
    </defs>
    
    <!-- Chart content container -->
    <g id="chartContent" clip-path="url(#chartClip)">
      <g id="chartLines"></g>
      <g id="chartPoints"></g>
    </g>
    
    <!-- Axis labels -->
    <text x="600" y="550" text-anchor="middle" class="label-text">Time</text>
    <text x="-250" y="-40" text-anchor="middle" transform="rotate(-90)" class="label-text">Latency (ms)</text>
  </g>
  
  <!-- Horizontal Scrollbar -->
  <g id="scrollbar" transform="translate(80, 680)" style="display: none;">
    <rect class="scroll-track" x="0" y="0" width="1200" height="20" rx="10"/>
    <rect id="scrollThumb" class="scroll-thumb" x="0" y="2" width="100" height="16" rx="8"/>
  </g>
  
  <!-- Tooltip -->
  <g id="tooltip" class="tooltip">
    <rect class="tooltip-bg" width="280" height="180" rx="5"/>
    <g id="tooltipContent" transform="translate(10, 20)"></g>
  </g>
  
  <!-- Hidden file input -->
  <foreignObject x="0" y="0" width="1" height="1" style="overflow: visible;">
    <input type="file" id="fileInput" accept=".jsonl" style="display: none;" xmlns="http://www.w3.org/1999/xhtml"/>
  </foreignObject>
  
  <script type="text/javascript"><![CDATA[
    let data = [];
    let filteredData = [];
    let currentBucketType = '5min';
    let viewportStart = 0;
    let viewportWidth = 1200;
    let totalDataWidth = 1200;
    let isDragging = false;
    let dragStartX = 0;
    let scrollStartX = 0;
    
    // Color scheme for lines
    const colors = {
      p50: '#ff6b6b',
      p90: '#ffd93d',
      p95: '#6bcf7f',
      p99: '#4a9eff',
      p99_9: '#c77dff',
      p99_99: '#ff006e',
      avg: '#888888',
      min: '#555555',
      max: '#aaaaaa'
    };
    
    // File input handling
    document.getElementById('fileLabel').addEventListener('click', function() {
      document.getElementById('fileInput').click();
    });
    
    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(event) {
          try {
            // Parse JSONL file
            const lines = event.target.result.trim().split('\n');
            data = lines.map(line => JSON.parse(line));
            
            // Update UI
            document.getElementById('fileLabel').textContent = file.name;
            document.getElementById('bucketSelector').style.display = 'block';
            document.getElementById('legend').style.display = 'block';
            document.getElementById('scrollbar').style.display = 'block';
            
            // Create bucket type buttons dynamically
            createBucketButtons();
            
            // Initial render
            updateChart();
          } catch (error) {
            alert('Error parsing file: ' + error.message);
          }
        };
        reader.readAsText(file);
      }
    });
    
    function createBucketButtons() {
      const bucketButtons = document.getElementById('bucketButtons');
      bucketButtons.innerHTML = ''; // Clear existing buttons
      
      // Get unique bucket types
      const bucketTypes = [...new Set(data.map(d => d.bucket_type))].sort();
      
      if (bucketTypes.length === 0) return;
      
      // Set the first bucket type as default
      currentBucketType = bucketTypes[0];
      
      // Create a button for each bucket type
      bucketTypes.forEach((type, index) => {
        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('transform', `translate(${index * 80}, 0)`);
        g.style.cursor = 'pointer';
        
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('class', index === 0 ? 'control-btn active' : 'control-btn');
        rect.setAttribute('width', '70');
        rect.setAttribute('height', '25');
        rect.setAttribute('rx', '3');
        
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', '35');
        text.setAttribute('y', '17');
        text.setAttribute('text-anchor', 'middle');
        text.style.fill = 'white';
        text.style.fontSize = '12px';
        text.style.pointerEvents = 'none';
        text.textContent = type;
        
        g.appendChild(rect);
        g.appendChild(text);
        
        g.addEventListener('click', function() {
          setBucketType(type, this);
        });
        
        bucketButtons.appendChild(g);
      });
    }
    
    function setBucketType(type, element) {
      currentBucketType = type;
      // Remove active class from all buttons
      document.querySelectorAll('#bucketButtons .control-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      // Add active class to clicked button
      element.querySelector('.control-btn').classList.add('active');
      // Reset viewport to start
      viewportStart = 0;
      updateChart();
    }
    
    function updateChart() {
      if (data.length === 0) return;
      
      // Filter data by bucket type
      filteredData = data.filter(d => d.bucket_type === currentBucketType)
        .sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
      
      if (filteredData.length === 0) return;
      
      // Calculate dimensions
      const pointSpacing = 15;
      totalDataWidth = Math.max(1200, filteredData.length * pointSpacing);
      
      // Update scrollbar
      updateScrollbar();
      
      // Draw chart
      drawChart();
    }
    
    function drawChart() {
      const chartLines = document.getElementById('chartLines');
      const chartPoints = document.getElementById('chartPoints');
      const gridLines = document.getElementById('gridLines');
      const xAxis = document.getElementById('xAxis');
      const yAxis = document.getElementById('yAxis');
      
      // Clear existing content
      chartLines.innerHTML = '';
      chartPoints.innerHTML = '';
      gridLines.innerHTML = '';
      xAxis.innerHTML = '';
      yAxis.innerHTML = '';
      
      if (filteredData.length === 0) return;
      
      // Calculate visible data range
      const pointSpacing = totalDataWidth / filteredData.length;
      const startIndex = Math.floor(viewportStart / pointSpacing);
      const endIndex = Math.ceil((viewportStart + viewportWidth) / pointSpacing);
      const visibleData = filteredData.slice(Math.max(0, startIndex - 1), Math.min(filteredData.length, endIndex + 1));
      
      // Calculate Y scale
      let maxY = 0;
      visibleData.forEach(d => {
        maxY = Math.max(maxY, d.p99_99_ms || 0, d.max_ms || 0);
      });
      maxY = maxY * 1.1; // Add 10% padding
      
      // Draw grid lines
      const yTicks = 10;
      for (let i = 0; i <= yTicks; i++) {
        const y = (i / yTicks) * 500;
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', 0);
        line.setAttribute('y1', 500 - y);
        line.setAttribute('x2', 1200);
        line.setAttribute('y2', 500 - y);
        line.setAttribute('class', 'grid-line');
        gridLines.appendChild(line);
        
        // Y axis label
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', -10);
        text.setAttribute('y', 500 - y + 3);
        text.setAttribute('class', 'axis-text');
        text.setAttribute('text-anchor', 'end');
        text.textContent = ((maxY * i / yTicks).toFixed(1)) + 'ms';
        yAxis.appendChild(text);
      }
      
      // Draw lines for each percentile
      const metrics = ['p50_ms', 'p90_ms', 'p95_ms', 'p99_ms', 'p99_9_ms', 'p99_99_ms'];
      const metricColors = ['p50', 'p90', 'p95', 'p99', 'p99_9', 'p99_99'];
      
      metrics.forEach((metric, idx) => {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        let d = '';
        
        filteredData.forEach((point, i) => {
          const x = (i * pointSpacing) - viewportStart;
          const y = 500 - (point[metric] / maxY) * 500;
          
          if (x >= -100 && x <= 1300) { // Only draw visible points with some buffer
            if (i === 0 || x < -100) {
              d += `M ${x} ${y} `;
            } else {
              d += `L ${x} ${y} `;
            }
          }
        });
        
        path.setAttribute('d', d);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', colors[metricColors[idx]]);
        path.setAttribute('stroke-width', '2');
        path.setAttribute('stroke-linejoin', 'round');
        path.setAttribute('stroke-linecap', 'round');
        chartLines.appendChild(path);
        
        // Add interactive points
        filteredData.forEach((point, i) => {
          const x = (i * pointSpacing) - viewportStart;
          const y = 500 - (point[metric] / maxY) * 500;
          
          if (x >= 0 && x <= 1200) {
            const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            circle.setAttribute('cx', x);
            circle.setAttribute('cy', y);
            circle.setAttribute('r', '3');
            circle.setAttribute('fill', colors[metricColors[idx]]);
            circle.setAttribute('stroke', 'none');
            circle.setAttribute('opacity', '0');
            circle.setAttribute('style', 'cursor: pointer;');
            circle.setAttribute('data-point', JSON.stringify(point));
            
            circle.addEventListener('mouseenter', function(e) {
              this.setAttribute('opacity', '1');
              this.setAttribute('r', '5');
              showTooltip(e, point);
            });
            
            circle.addEventListener('mouseleave', function() {
              this.setAttribute('opacity', '0');
              this.setAttribute('r', '3');
              hideTooltip();
            });
            
            chartPoints.appendChild(circle);
          }
        });
      });
      
      // Draw X axis labels
      const xLabelInterval = Math.ceil(filteredData.length / 20);
      filteredData.forEach((point, i) => {
        if (i % xLabelInterval === 0) {
          const x = (i * pointSpacing) - viewportStart;
          if (x >= 0 && x <= 1200) {
            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', 520);
            text.setAttribute('class', 'axis-text');
            text.setAttribute('text-anchor', 'middle');
            text.setAttribute('transform', `rotate(-45 ${x} 520)`);
            const date = new Date(point.start_time);
            text.textContent = date.toLocaleString('en-US', { 
              month: 'short', 
              day: 'numeric', 
              hour: '2-digit', 
              minute: '2-digit' 
            });
            xAxis.appendChild(text);
          }
        }
      });
    }
    
    function updateScrollbar() {
      const scrollThumb = document.getElementById('scrollThumb');
      const thumbWidth = Math.max(50, (viewportWidth / totalDataWidth) * 1200);
      const thumbPosition = (viewportStart / totalDataWidth) * 1200;
      
      scrollThumb.setAttribute('width', thumbWidth);
      scrollThumb.setAttribute('x', Math.min(thumbPosition, 1200 - thumbWidth));
    }
    
    // Scrollbar interaction
    const scrollThumb = document.getElementById('scrollThumb');
    
    scrollThumb.addEventListener('mousedown', function(e) {
      isDragging = true;
      dragStartX = e.clientX;
      scrollStartX = parseFloat(scrollThumb.getAttribute('x'));
      e.preventDefault();
    });
    
    document.addEventListener('mousemove', function(e) {
      if (isDragging) {
        const deltaX = e.clientX - dragStartX;
        const thumbWidth = parseFloat(scrollThumb.getAttribute('width'));
        const newX = Math.max(0, Math.min(1200 - thumbWidth, scrollStartX + deltaX));
        
        scrollThumb.setAttribute('x', newX);
        viewportStart = (newX / 1200) * totalDataWidth;
        drawChart();
      }
    });
    
    document.addEventListener('mouseup', function() {
      isDragging = false;
    });
    
    // Tooltip functions
    function showTooltip(event, point) {
      const tooltip = document.getElementById('tooltip');
      const tooltipContent = document.getElementById('tooltipContent');
      
      // Clear content
      tooltipContent.innerHTML = '';
      
      // Add content
      const lines = [
        `Time: ${new Date(point.start_time).toLocaleString()}`,
        `Messages: ${point.total_messages.toLocaleString()}`,
        `Min: ${point.min_ms.toFixed(3)}ms`,
        `Avg: ${point.avg_ms.toFixed(3)}ms`,
        `Max: ${point.max_ms.toFixed(3)}ms`,
        `P50: ${point.p50_ms.toFixed(3)}ms`,
        `P90: ${point.p90_ms.toFixed(3)}ms`,
        `P95: ${point.p95_ms.toFixed(3)}ms`,
        `P99: ${point.p99_ms.toFixed(3)}ms`,
        `P99.9: ${point.p99_9_ms.toFixed(3)}ms`,
        `P99.99: ${point.p99_99_ms.toFixed(3)}ms`
      ];
      
      lines.forEach((line, i) => {
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('x', 5);
        text.setAttribute('y', i * 15);
        text.setAttribute('class', 'tooltip-text');
        text.textContent = line;
        tooltipContent.appendChild(text);
      });
      
      // Position tooltip
      const rect = event.target.getBoundingClientRect();
      const svg = document.querySelector('svg').getBoundingClientRect();
      let x = rect.left - svg.left + 10;
      let y = rect.top - svg.top - 190;
      
      // Keep tooltip within bounds
      if (x + 280 > svg.width) x = rect.left - svg.left - 290;
      if (y < 10) y = rect.bottom - svg.top + 10;
      
      tooltip.setAttribute('transform', `translate(${x}, ${y})`);
      tooltip.style.opacity = '1';
    }
    
    function hideTooltip() {
      document.getElementById('tooltip').style.opacity = '0';
    }
    
    // Mouse wheel scrolling on chart
    document.getElementById('chartArea').addEventListener('wheel', function(e) {
      if (filteredData.length === 0) return;
      
      e.preventDefault();
      const delta = e.deltaX || e.deltaY;
      const scrollSpeed = 2;
      
      viewportStart = Math.max(0, Math.min(totalDataWidth - viewportWidth, viewportStart + delta * scrollSpeed));
      updateScrollbar();
      drawChart();
    });
  ]]></script>
</svg>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latency Analytics Dashboard</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        .file-picker {
            margin-bottom: 20px;
            padding: 15px;
            border: 2px dashed #ccc;
            border-radius: 8px;
            text-align: center;
        }
        .file-picker input {
            margin: 10px;
            padding: 8px 16px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .status {
            margin-top: 8px;
            color: #666;
            font-size: 12px;
        }
        .graph-container {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            overflow: hidden;
        }
        .graph-header {
            background: #f8f9fa;
            padding: 15px;
            border-bottom: 1px solid #e0e0e0;
            font-weight: 600;
        }
        .graph-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            border-bottom: 1px solid #e0e0e0;
            scroll-behavior: smooth;
            width: 100%;
            max-width: 1160px; /* Force a constrained width to ensure scrolling */
            /* Better scrollbar styling for webkit browsers */
            scrollbar-width: thin;
            scrollbar-color: #ccc #f0f0f0;
        }
        .graph-scroll::-webkit-scrollbar {
            height: 12px;
        }
        .graph-scroll::-webkit-scrollbar-track {
            background: #f0f0f0;
            border-radius: 6px;
        }
        .graph-scroll::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 6px;
        }
        .graph-scroll::-webkit-scrollbar-thumb:hover {
            background: #999;
        }
        svg {
            display: block;
        }
        .axis-line {
            stroke: #666;
            stroke-width: 1;
        }
        .axis-text {
            font-size: 12px;
            fill: #666;
        }
        .grid-line {
            stroke: #e0e0e0;
            stroke-width: 0.5;
            stroke-dasharray: 2,2;
        }
        .percentile-line {
            fill: none;
            stroke-width: 2;
        }
        .p50 { stroke: #2196F3; }
        .p90 { stroke: #FF9800; }
        .p95 { stroke: #F44336; }
        .p99 { stroke: #9C27B0; }
        .p999 { stroke: #795548; }
        .p9999 { stroke: #607D8B; }
        .data-point {
            fill: currentColor;
            cursor: pointer;
            opacity: 0.7;
        }
        .data-point:hover {
            opacity: 1;
        }
        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            line-height: 1.4;
        }
        .legend {
            padding: 15px;
            background: #f8f9fa;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 16px;
            height: 2px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Latency Analytics Dashboard</h1>

        <div class="file-picker">
            <input type="file" id="dataFile" accept=".jsonl,.txt" />
            <div id="status" class="status">Please select a JSONL file to load data</div>
        </div>

        <div class="graph-container">
            <div class="graph-header">5-Minute Buckets - Latency Percentiles</div>
            <div class="graph-scroll" id="scroll5min">
                <svg id="graph5min" width="1000" height="400">
                    <text class="axis-text" x="60" y="40">Load a JSONL file to see 5-minute bucket data</text>
                </svg>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color p50"></div>P50</div>
                <div class="legend-item"><div class="legend-color p90"></div>P90</div>
                <div class="legend-item"><div class="legend-color p95"></div>P95</div>
                <div class="legend-item"><div class="legend-color p99"></div>P99</div>
                <div class="legend-item"><div class="legend-color p999"></div>P99.9</div>
                <div class="legend-item"><div class="legend-color p9999"></div>P99.99</div>
            </div>
        </div>

        <div class="graph-container">
            <div class="graph-header">1-Hour Buckets - Latency Percentiles</div>
            <div class="graph-scroll" id="scroll1hr">
                <svg id="graph1hr" width="1000" height="400">
                    <text class="axis-text" x="60" y="40">Load a JSONL file to see 1-hour bucket data</text>
                </svg>
            </div>
            <div class="legend">
                <div class="legend-item"><div class="legend-color p50"></div>P50</div>
                <div class="legend-item"><div class="legend-color p90"></div>P90</div>
                <div class="legend-item"><div class="legend-color p95"></div>P95</div>
                <div class="legend-item"><div class="legend-color p99"></div>P99</div>
                <div class="legend-item"><div class="legend-color p999"></div>P99.9</div>
                <div class="legend-item"><div class="legend-color p9999"></div>P99.99</div>
            </div>
        </div>
    </div>

    <div class="tooltip" id="tooltip" style="display: none;"></div>

    <script>
        let data5min = [];
        let data1hr = [];
        const tooltip = document.getElementById('tooltip');
        const statusEl = document.getElementById('status');

        const PERCENTILE_KEYS = ['p50_ms', 'p90_ms', 'p95_ms', 'p99_ms', 'p99_9_ms', 'p99_99_ms'];

        function setStatus(text) {
            if (statusEl) statusEl.textContent = text;
        }


        function sanitizeRecords(records) {
            // Keep records that have a bucket_type and at least one percentile present
            const valid = records.filter(d => d && d.bucket_type && PERCENTILE_KEYS.some(k => d[k] !== undefined && d[k] !== null));
            // Coerce numeric fields to numbers
            valid.forEach(d => {
                PERCENTILE_KEYS.forEach(k => {
                    if (d[k] !== undefined) {
                        const n = Number(d[k]);
                        d[k] = Number.isFinite(n) ? n : undefined;
                    }
                });
            });
            return valid;
        }

        function processData(rawData) {
            const cleaned = sanitizeRecords(rawData);
            data5min = cleaned.filter(d => String(d.bucket_type).toLowerCase() === '5min').sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
            data1hr = cleaned.filter(d => String(d.bucket_type).toLowerCase() === '1hr').sort((a, b) => new Date(a.start_time) - new Date(b.start_time));

            setStatus(`Rendering 5min graph (${data5min.length} records)...`);
            // Use setTimeout to allow status update to render
            setTimeout(() => {
                renderGraph('graph5min', data5min, '5min');
                setStatus(`Rendering 1hr graph (${data1hr.length} records)...`);
                setTimeout(() => {
                    renderGraph('graph1hr', data1hr, '1hr');
                    setStatus(`✅ Loaded: ${cleaned.length} records • 5min: ${data5min.length} • 1hr: ${data1hr.length}`);
                }, 1);
            }, 1);
        }

        function renderGraph(svgId, data, bucketType) {
            const svg = document.getElementById(svgId);
            const margin = { top: 20, right: 40, bottom: 60, left: 60 };
            const dataset = data;
            
            // Calculate width to ensure scrolling
            const pointSpacing = 15;
            const width = Math.max(1000, dataset.length * pointSpacing);
            console.log(`SVG width for ${bucketType}: ${width}px (${dataset.length} points * ${pointSpacing}px)`);
            const height = 400;
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            svg.setAttribute('width', width);
            svg.setAttribute('height', height);
            
            // Clear existing content
            while (svg.firstChild) {
                svg.removeChild(svg.firstChild);
            }

            if (dataset.length === 0) {
                const noDataText = createSVGElement('text', {
                    'class': 'axis-text',
                    'x': margin.left,
                    'y': margin.top + 20
                });
                noDataText.textContent = `No ${bucketType} data`;
                svg.appendChild(noDataText);
                return;
            }

            // Calculate scales
            const safeValues = dataset.flatMap(d => PERCENTILE_KEYS.map(k => Number.isFinite(d[k]) ? d[k] : NaN)).filter(v => Number.isFinite(v));
            const maxLatency = safeValues.length ? Math.max(...safeValues) : 0;
            if (!(maxLatency > 0)) {
                const noValidText = createSVGElement('text', {
                    'class': 'axis-text',
                    'x': margin.left,
                    'y': margin.top + 20
                });
                noValidText.textContent = `No valid percentile values in ${bucketType} data`;
                svg.appendChild(noValidText);
                return;
            }

            const yScale = (value) => margin.top + chartHeight - (value / maxLatency * chartHeight);
            const xScale = (index) => margin.left + (index / (dataset.length - 1 || 1)) * chartWidth;

            // Grid lines
            const gridLines = [0, maxLatency * 0.25, maxLatency * 0.5, maxLatency * 0.75, maxLatency];
            gridLines.forEach(value => {
                const y = yScale(value);
                const gridLine = createSVGElement('line', {
                    'class': 'grid-line',
                    'x1': margin.left,
                    'y1': y,
                    'x2': margin.left + chartWidth,
                    'y2': y
                });
                svg.appendChild(gridLine);

                const gridLabel = createSVGElement('text', {
                    'class': 'axis-text',
                    'x': margin.left - 10,
                    'y': y + 4,
                    'text-anchor': 'end'
                });
                gridLabel.textContent = `${value.toFixed(1)}ms`;
                svg.appendChild(gridLabel);
            });

            // Y-axis
            const yAxis = createSVGElement('line', {
                'class': 'axis-line',
                'x1': margin.left,
                'y1': margin.top,
                'x2': margin.left,
                'y2': margin.top + chartHeight
            });
            svg.appendChild(yAxis);

            const yLabel = createSVGElement('text', {
                'class': 'axis-text',
                'x': 20,
                'y': margin.top + chartHeight/2,
                'text-anchor': 'middle',
                'transform': `rotate(-90, 20, ${margin.top + chartHeight/2})`
            });
            yLabel.textContent = 'Latency (ms)';
            svg.appendChild(yLabel);

            // X-axis
            const xAxis = createSVGElement('line', {
                'class': 'axis-line',
                'x1': margin.left,
                'y1': margin.top + chartHeight,
                'x2': margin.left + chartWidth,
                'y2': margin.top + chartHeight
            });
            svg.appendChild(xAxis);

            // X-axis labels
            dataset.forEach((d, i) => {
                const x = xScale(i);
                const time = new Date(d.start_time).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                const xLabel = createSVGElement('text', {
                    'class': 'axis-text',
                    'x': x,
                    'y': margin.top + chartHeight + 20,
                    'text-anchor': 'middle'
                });
                xLabel.textContent = time;
                svg.appendChild(xLabel);
            });

            // Percentile lines and points
            const percentiles = PERCENTILE_KEYS;
            const colors = ['p50', 'p90', 'p95', 'p99', 'p999', 'p9999'];

            percentiles.forEach((percentile, pIndex) => {
                // Line path
                let pathData = '';
                dataset.forEach((d, i) => {
                    const v = d[percentile];
                    if (Number.isFinite(v)) {
                        pathData += (pathData ? ' L ' : 'M ') + xScale(i) + ' ' + yScale(v);
                    }
                });
                if (pathData) {
                    const path = createSVGElement('path', {
                        'class': `percentile-line ${colors[pIndex]}`,
                        'd': pathData
                    });
                    svg.appendChild(path);
                }

                // Data points
                dataset.forEach((d, i) => {
                    const v = d[percentile];
                    if (!Number.isFinite(v)) return;
                    const x = xScale(i);
                    const y = yScale(v);

                    const point = createSVGElement('circle', {
                        'class': `data-point ${colors[pIndex]}`,
                        'cx': x,
                        'cy': y,
                        'r': 3,
                        'data-info': JSON.stringify(d),
                        'data-percentile': percentile
                    });

                    // Add event listeners
                    point.addEventListener('mouseenter', showTooltip);
                    point.addEventListener('mouseleave', hideTooltip);
                    point.addEventListener('mousemove', moveTooltip);

                    svg.appendChild(point);
                });
            });

            // Add scroll end indicator
            const endRect = createSVGElement('rect', {
                'x': width - 50,
                'y': 10,
                'width': 40,
                'height': 20,
                'fill': 'red',
                'opacity': 0.5
            });
            svg.appendChild(endRect);

            const endText = createSVGElement('text', {
                'x': width - 30,
                'y': 25,
                'text-anchor': 'middle',
                'class': 'axis-text',
                'fill': 'red'
            });
            endText.textContent = 'END';
            svg.appendChild(endText);
        }

        function createSVGElement(tag, attributes) {
            const element = document.createElementNS('http://www.w3.org/2000/svg', tag);
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
            return element;
        }

        function showTooltip(event) {
            const data = JSON.parse(event.target.dataset.info);
            const percentile = event.target.dataset.percentile;

            const tooltipContent = `
                <strong>${data.filename}</strong><br>
                <strong>Time:</strong> ${new Date(data.start_time).toLocaleString()} - ${new Date(data.end_time).toLocaleString()}<br>
                <strong>Bucket:</strong> ${data.bucket_type} (Index: ${data.bucket_index})<br>
                <strong>Messages:</strong> ${data.total_messages.toLocaleString()}<br>
                <hr>
                <strong>Current:</strong> ${percentile.replace('_ms', '').toUpperCase()} = ${data[percentile].toFixed(2)}ms<br>
                <hr>
                <strong>Min:</strong> ${data.min_ms.toFixed(2)}ms<br>
                <strong>Avg:</strong> ${data.avg_ms.toFixed(2)}ms<br>
                <strong>Max:</strong> ${data.max_ms.toFixed(2)}ms<br>
                <strong>P50:</strong> ${data.p50_ms.toFixed(2)}ms<br>
                <strong>P90:</strong> ${data.p90_ms.toFixed(2)}ms<br>
                <strong>P95:</strong> ${data.p95_ms.toFixed(2)}ms<br>
                <strong>P99:</strong> ${data.p99_ms.toFixed(2)}ms<br>
                <strong>P99.9:</strong> ${data.p99_9_ms.toFixed(2)}ms<br>
                <strong>P99.99:</strong> ${data.p99_99_ms.toFixed(2)}ms
            `;

            tooltip.innerHTML = tooltipContent;
            tooltip.style.display = 'block';
            moveTooltip(event);
        }

        function moveTooltip(event) {
            const rect = document.body.getBoundingClientRect();
            tooltip.style.left = (event.clientX + 10) + 'px';
            tooltip.style.top = (event.clientY - 10) + 'px';
        }

        function hideTooltip() {
            tooltip.style.display = 'none';
        }


        // File picker functionality
        document.getElementById('dataFile').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            setStatus(`Loading ${file.name}... (${(file.size / 1024 / 1024).toFixed(1)}MB)`);
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    setStatus(`Parsing ${file.name}...`);
                    const lines = e.target.result.split('\n').filter(line => line.trim());
                    
                    // Parse with progress updates for large files
                    const parsed = [];
                    const batchSize = 1000;
                    
                    function parseBatch(startIndex) {
                        const endIndex = Math.min(startIndex + batchSize, lines.length);
                        
                        for (let i = startIndex; i < endIndex; i++) {
                            try {
                                parsed.push(JSON.parse(lines[i]));
                            } catch (parseError) {
                                console.warn(`Skipping malformed line ${i + 1}: ${parseError.message}`);
                            }
                        }
                        
                        if (endIndex < lines.length) {
                            setStatus(`Parsing ${file.name}... ${Math.round((endIndex / lines.length) * 100)}%`);
                            // Use setTimeout to prevent UI blocking
                            setTimeout(() => parseBatch(endIndex), 1);
                        } else {
                            setStatus(`Parsed ${parsed.length} records from ${file.name}. Rendering graphs...`);
                            processData(parsed);
                        }
                    }
                    
                    parseBatch(0);
                    
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                    setStatus('Error reading file');
                }
            };
            
            reader.onerror = function() {
                setStatus('Error reading file');
            };
            
            reader.readAsText(file);
        });

    </script>
</body>
</html>
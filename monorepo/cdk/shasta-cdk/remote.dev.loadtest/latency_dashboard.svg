<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
     width="1400" height="1000" viewBox="0 0 1400 1000">
  
  <!-- Title -->
  <text x="700" y="30" text-anchor="middle" font-family="Arial, sans-serif" 
        font-size="24" font-weight="bold" fill="#333">
    RedPanda Latency Analysis Dashboard
  </text>
  
  <!-- Loading indicator -->
  <text id="loading" x="700" y="500" text-anchor="middle" font-family="Arial, sans-serif" 
        font-size="16" fill="#666">
    Loading bucket_analysis.jsonl...
  </text>
  
  <!-- Main content (hidden initially) -->
  <g id="content" style="display: none">
    
    <!-- Overall Latency Time Series -->
    <g id="timeseries">
      <text x="50" y="80" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#333">
        Overall Latency Percentiles Over Time
      </text>
      <rect x="50" y="90" width="800" height="200" fill="none" stroke="#ccc" stroke-width="1"/>
      
      <!-- Time series will be drawn here -->
      <g id="timeseriesData"></g>
      
      <!-- Legend -->
      <g id="timeseriesLegend" transform="translate(870, 100)">
        <text x="0" y="0" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#333">Legend:</text>
      </g>
    </g>
    
    <!-- Message Volume -->
    <g id="volume">
      <text x="50" y="330" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#333">
        Message Volume Per 5-Minute Bucket
      </text>
      <rect x="50" y="340" width="800" height="120" fill="none" stroke="#ccc" stroke-width="1"/>
      <g id="volumeData"></g>
    </g>
    
    <!-- Partition Heatmap -->
    <g id="heatmap">
      <text x="50" y="500" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#333">
        Partition P99.99 Latency Heatmap (ms)
      </text>
      <rect x="50" y="510" width="1000" height="300" fill="none" stroke="#ccc" stroke-width="1"/>
      <g id="heatmapData"></g>
      
      <!-- Color scale -->
      <g id="colorScale" transform="translate(1070, 520)">
        <text x="0" y="0" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#333">P99.99 (ms)</text>
      </g>
    </g>
    
    <!-- Summary Statistics -->
    <g id="summary" transform="translate(50, 830)">
      <text x="0" y="0" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#333">
        Summary Statistics
      </text>
      <rect x="0" y="10" width="600" height="120" fill="none" stroke="#ccc" stroke-width="1"/>
      <g id="summaryData"></g>
    </g>
    
    <!-- File List -->
    <g id="fileList" transform="translate(700, 830)">
      <text x="0" y="0" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#333">
        Processed Files
      </text>
      <rect x="0" y="10" width="400" height="120" fill="none" stroke="#ccc" stroke-width="1"/>
      <g id="fileData"></g>
    </g>
    
  </g>
  
  <!-- JavaScript -->
  <script type="text/javascript"><![CDATA[
    
    let bucketData = [];
    let partitions = new Set();
    let files = new Set();
    
    // Load and parse JSONL data
    async function loadData() {
      try {
        const response = await fetch('bucket_analysis.jsonl');
        const text = await response.text();
        
        // Parse JSONL (one JSON object per line)
        const lines = text.trim().split('\n').filter(line => line.trim());
        bucketData = lines.map(line => JSON.parse(line));
        
        // Extract unique partitions and files
        bucketData.forEach(bucket => {
          files.add(bucket.filename);
          bucket.partition_latency_stats.forEach(stat => {
            partitions.add(stat.Partition);
          });
        });
        
        console.log(`Loaded ${bucketData.length} buckets from ${files.size} files`);
        console.log(`Found ${partitions.size} partitions`);
        
        // Hide loading, show content
        document.getElementById('loading').style.display = 'none';
        document.getElementById('content').style.display = 'block';
        
        // Generate visualizations
        drawTimeSeries();
        drawVolume();
        drawHeatmap();
        drawSummary();
        drawFileList();
        
      } catch (error) {
        document.getElementById('loading').textContent = 'Error loading bucket_analysis.jsonl: ' + error.message;
        console.error('Error loading data:', error);
      }
    }
    
    // Draw overall latency time series
    function drawTimeSeries() {
      const svg = document.getElementById('timeseriesData');
      const width = 800;
      const height = 200;
      const margin = {top: 10, right: 10, bottom: 30, left: 60};
      
      if (bucketData.length === 0) return;
      
      // Sample data for performance (max 1000 points)
      const maxPoints = 1000;
      const step = Math.max(1, Math.floor(bucketData.length / maxPoints));
      const sampledData = bucketData.filter((_, i) => i % step === 0);
      
      // Find value ranges
      const minTime = new Date(Math.min(...sampledData.map(d => new Date(d.start_time))));
      const maxTime = new Date(Math.max(...sampledData.map(d => new Date(d.start_time))));
      const maxLatency = Math.max(...bucketData.map(d => Math.max(d.overall_p99_99_ms, d.overall_p99_ms, d.overall_p95_ms)));
      
      // Create scales
      const xScale = (timestamp) => {
        const t = new Date(timestamp);
        return margin.left + ((t - minTime) / (maxTime - minTime)) * (width - margin.left - margin.right);
      };
      
      const yScale = (latency) => {
        return height - margin.bottom - (latency / maxLatency) * (height - margin.top - margin.bottom);
      };
      
      // Draw axes
      svg.innerHTML = `
        <line x1="${margin.left}" y1="${height - margin.bottom}" x2="${width - margin.right}" y2="${height - margin.bottom}" 
              stroke="#333" stroke-width="1"/>
        <line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${height - margin.bottom}" 
              stroke="#333" stroke-width="1"/>
        <text x="${width/2}" y="${height - 5}" text-anchor="middle" font-family="Arial" font-size="12" fill="#666">Time</text>
        <text x="15" y="${height/2}" text-anchor="middle" font-family="Arial" font-size="12" fill="#666" 
              transform="rotate(-90 15 ${height/2})">Latency (ms)</text>
      `;
      
      // Add sampling note if data was reduced
      if (step > 1) {
        svg.innerHTML += `
          <text x="${width - margin.right - 10}" y="${margin.top + 15}" text-anchor="end" font-family="Arial" font-size="10" fill="#666">
            Showing ${sampledData.length}/${bucketData.length} points
          </text>
        `;
      }
      
      // Draw latency lines
      const metrics = [
        {key: 'overall_p99_99_ms', color: '#d62728', label: 'P99.99'},
        {key: 'overall_p99_ms', color: '#ff7f0e', label: 'P99'},
        {key: 'overall_p95_ms', color: '#2ca02c', label: 'P95'},
        {key: 'overall_p50_ms', color: '#1f77b4', label: 'P50'}
      ];
      
      metrics.forEach(metric => {
        let path = '';
        sampledData.forEach((bucket, i) => {
          const x = xScale(bucket.start_time);
          const y = yScale(bucket[metric.key]);
          path += (i === 0 ? 'M' : 'L') + x + ',' + y;
        });
        
        const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        pathElement.setAttribute('d', path);
        pathElement.setAttribute('stroke', metric.color);
        pathElement.setAttribute('stroke-width', '2');
        pathElement.setAttribute('fill', 'none');
        svg.appendChild(pathElement);
      });
      
      // Draw legend
      const legend = document.getElementById('timeseriesLegend');
      metrics.forEach((metric, i) => {
        const y = 20 + i * 20;
        legend.innerHTML += `
          <line x1="0" y1="${y}" x2="20" y2="${y}" stroke="${metric.color}" stroke-width="2"/>
          <text x="25" y="${y + 4}" font-family="Arial" font-size="12" fill="#333">${metric.label}</text>
        `;
      });
    }
    
    // Draw message volume bars
    function drawVolume() {
      const svg = document.getElementById('volumeData');
      const width = 800;
      const height = 120;
      const margin = {top: 10, right: 10, bottom: 20, left: 60};
      
      if (bucketData.length === 0) return;
      
      const maxVolume = Math.max(...bucketData.map(d => d.total_messages));
      const availableWidth = width - margin.left - margin.right;
      
      // Ensure bars have minimum width and handle large datasets
      let barWidth = availableWidth / bucketData.length;
      let gap = 0;
      
      // If too many buckets, make bars overlap or sample data
      if (barWidth < 0.5) {
        barWidth = Math.max(0.5, availableWidth / Math.min(bucketData.length, 1000));
        gap = 0; // No gap for dense data
      } else if (barWidth > 2) {
        gap = 1; // Add gap for wider bars
        barWidth = Math.max(0.5, (availableWidth / bucketData.length) - gap);
      }
      
      svg.innerHTML = `
        <line x1="${margin.left}" y1="${height - margin.bottom}" x2="${width - margin.right}" y2="${height - margin.bottom}" 
              stroke="#333" stroke-width="1"/>
        <line x1="${margin.left}" y1="${margin.top}" x2="${margin.left}" y2="${height - margin.bottom}" 
              stroke="#333" stroke-width="1"/>
        <text x="15" y="${height/2}" text-anchor="middle" font-family="Arial" font-size="12" fill="#666" 
              transform="rotate(-90 15 ${height/2})">Messages</text>
      `;
      
      // Sample data if too many buckets to avoid performance issues
      const maxBars = 1000;
      const step = Math.max(1, Math.floor(bucketData.length / maxBars));
      
      for (let i = 0; i < bucketData.length; i += step) {
        const bucket = bucketData[i];
        const x = margin.left + (i / step) * (barWidth + gap);
        const barHeight = (bucket.total_messages / maxVolume) * (height - margin.top - margin.bottom);
        const y = height - margin.bottom - barHeight;
        
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        rect.setAttribute('x', x);
        rect.setAttribute('y', y);
        rect.setAttribute('width', barWidth);
        rect.setAttribute('height', barHeight);
        rect.setAttribute('fill', '#1f77b4');
        rect.setAttribute('opacity', '0.7');
        
        // Tooltip
        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
        title.textContent = `${bucket.total_messages} messages at ${new Date(bucket.start_time).toLocaleTimeString()}`;
        rect.appendChild(title);
        
        svg.appendChild(rect);
      }
    }
    
    // Draw partition latency heatmap
    function drawHeatmap() {
      const svg = document.getElementById('heatmapData');
      const width = 1000;
      const height = 300;
      
      if (bucketData.length === 0) return;
      
      const partitionArray = Array.from(partitions).sort((a, b) => a - b);
      
      // Limit heatmap resolution for performance
      const maxTimeBuckets = 500;
      const timeStep = Math.max(1, Math.floor(bucketData.length / maxTimeBuckets));
      const sampledBuckets = bucketData.filter((_, i) => i % timeStep === 0);
      
      const cellWidth = Math.max(1, width / sampledBuckets.length);
      const cellHeight = height / partitionArray.length;
      
      // Find latency range for color mapping
      let maxLatency = 0;
      bucketData.forEach(bucket => {
        bucket.partition_latency_stats.forEach(stat => {
          maxLatency = Math.max(maxLatency, stat.P99_99);
        });
      });
      
      // Color scale function
      const getColor = (latency) => {
        if (latency === 0) return '#f0f0f0';
        const intensity = Math.min(latency / maxLatency, 1);
        const red = Math.floor(255 * intensity);
        const green = Math.floor(255 * (1 - intensity * 0.8));
        const blue = Math.floor(255 * (1 - intensity));
        return `rgb(${red},${green},${blue})`;
      };
      
      // Draw heatmap cells (sampled for performance)
      sampledBuckets.forEach((bucket, timeIdx) => {
        const partitionMap = new Map();
        bucket.partition_latency_stats.forEach(stat => {
          partitionMap.set(stat.Partition, stat.P99_99);
        });
        
        partitionArray.forEach((partition, partIdx) => {
          const x = timeIdx * cellWidth;
          const y = partIdx * cellHeight;
          const latency = partitionMap.get(partition) || 0;
          
          const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
          rect.setAttribute('x', x);
          rect.setAttribute('y', y);
          rect.setAttribute('width', cellWidth);
          rect.setAttribute('height', cellHeight);
          rect.setAttribute('fill', getColor(latency));
          rect.setAttribute('stroke', cellWidth > 2 ? '#fff' : 'none');
          rect.setAttribute('stroke-width', cellWidth > 2 ? '0.5' : '0');
          
          // Tooltip
          const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
          title.textContent = `Partition ${partition}: ${latency.toFixed(2)}ms P99.99 at ${new Date(bucket.start_time).toLocaleTimeString()}`;
          rect.appendChild(title);
          
          svg.appendChild(rect);
        });
      });
      
      // Draw color scale
      const colorScale = document.getElementById('colorScale');
      const scaleSteps = 10;
      for (let i = 0; i < scaleSteps; i++) {
        const latency = (maxLatency / scaleSteps) * i;
        const y = 20 + i * 15;
        colorScale.innerHTML += `
          <rect x="0" y="${y}" width="20" height="12" fill="${getColor(latency)}"/>
          <text x="25" y="${y + 10}" font-family="Arial" font-size="10" fill="#333">${latency.toFixed(1)}</text>
        `;
      }
      
      // Add note about sampling if data was reduced
      if (timeStep > 1) {
        svg.innerHTML += `
          <text x="10" y="290" font-family="Arial" font-size="10" fill="#666">
            Note: Showing every ${timeStep}${timeStep === 2 ? 'nd' : timeStep === 3 ? 'rd' : 'th'} bucket (${sampledBuckets.length}/${bucketData.length}) for performance
          </text>
        `;
      }
    }
    
    // Draw summary statistics
    function drawSummary() {
      const svg = document.getElementById('summaryData');
      
      if (bucketData.length === 0) return;
      
      // Calculate overall statistics
      const totalMessages = bucketData.reduce((sum, bucket) => sum + bucket.total_messages, 0);
      const avgP9999 = bucketData.reduce((sum, bucket) => sum + bucket.overall_p99_99_ms, 0) / bucketData.length;
      const maxP9999 = Math.max(...bucketData.map(d => d.overall_p99_99_ms));
      const minP9999 = Math.min(...bucketData.map(d => d.overall_p99_99_ms));
      
      const timeSpan = new Date(bucketData[bucketData.length - 1].end_time) - new Date(bucketData[0].start_time);
      const hours = timeSpan / (1000 * 60 * 60);
      const throughput = totalMessages / (timeSpan / 1000);
      
      svg.innerHTML = `
        <text x="20" y="30" font-family="Arial" font-size="12" fill="#333">Total Messages: ${totalMessages.toLocaleString()}</text>
        <text x="20" y="45" font-family="Arial" font-size="12" fill="#333">Time Span: ${hours.toFixed(1)} hours</text>
        <text x="20" y="60" font-family="Arial" font-size="12" fill="#333">Avg Throughput: ${throughput.toFixed(1)} msg/sec</text>
        <text x="20" y="75" font-family="Arial" font-size="12" fill="#333">Buckets: ${bucketData.length}</text>
        
        <text x="300" y="30" font-family="Arial" font-size="12" fill="#333">Avg P99.99: ${avgP9999.toFixed(2)}ms</text>
        <text x="300" y="45" font-family="Arial" font-size="12" fill="#333">Max P99.99: ${maxP9999.toFixed(2)}ms</text>
        <text x="300" y="60" font-family="Arial" font-size="12" fill="#333">Min P99.99: ${minP9999.toFixed(2)}ms</text>
        <text x="300" y="75" font-family="Arial" font-size="12" fill="#333">Partitions: ${partitions.size}</text>
      `;
    }
    
    // Draw file list
    function drawFileList() {
      const svg = document.getElementById('fileData');
      
      const fileArray = Array.from(files);
      fileArray.forEach((filename, i) => {
        const y = 30 + i * 15;
        svg.innerHTML += `
          <text x="20" y="${y}" font-family="Arial" font-size="11" fill="#333">â€¢ ${filename}</text>
        `;
      });
    }
    
    // Load data when page loads
    loadData();
    
  ]]></script>
  
</svg>

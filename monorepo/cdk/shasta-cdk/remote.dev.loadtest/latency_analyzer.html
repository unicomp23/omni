<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RedPanda Latency Analyzer</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        h1 {
            margin: 0;
            color: #333;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .control-group {
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 10px;
        }
        label {
            font-weight: 500;
            margin-right: 8px;
        }
        select, input, button {
            padding: 6px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }
        button:hover {
            background: #45a049;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-title {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-scroll-container {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 10px;
        }
        .chart-scroll-container::-webkit-scrollbar {
            height: 8px;
        }
        .chart-scroll-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .chart-scroll-container::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 4px;
        }
        .chart-scroll-container::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
        canvas {
            height: 300px;
            display: block;
        }
        .table-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background: #f8f9fa;
            font-weight: 500;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        .error {
            color: #d32f2f;
            padding: 20px;
            background: #ffebee;
            border-radius: 4px;
            margin: 20px 0;
        }
        .file-input-container {
            margin: 20px 0;
        }
        #fileInput {
            display: none;
        }
        .file-label {
            display: inline-block;
            padding: 10px 20px;
            background: #2196F3;
            color: white;
            border-radius: 4px;
            cursor: pointer;
        }
        .file-label:hover {
            background: #1976D2;
        }
        .percentile-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        .percentile-item {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .percentile-label {
            font-size: 11px;
            color: #666;
            margin-bottom: 4px;
        }
        .percentile-value {
            font-size: 16px;
            font-weight: bold;
        }
        .p50 { color: #1f77b4; }
        .p95 { color: #2ca02c; }
        .p99 { color: #ff7f0e; }
        .p999 { color: #e377c2; }
        .p9999 { color: #d62728; }

        /* Tooltip styles */
        .tooltip-bubble {
            position: absolute;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
            pointer-events: none;
            z-index: 1000;
            min-width: 280px;
            display: none;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tooltip-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
        }

        .tooltip-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 10px;
        }

        .tooltip-stat {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 0;
        }

        .tooltip-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
        }

        .tooltip-value {
            font-weight: bold;
            font-size: 14px;
        }

        .tooltip-messages {
            font-size: 11px;
            color: #888;
            text-align: center;
            padding-top: 8px;
            border-top: 1px solid #e0e0e0;
        }

        #partitionContainer {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .partition-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .partition-title {
            font-size: 18px;
            font-weight: bold;
            color: #333;
        }

        .partition-info {
            font-size: 12px;
            color: #666;
        }

        .partition-table {
            width: 100%;
            border-collapse: collapse;
        }

        .partition-table th {
            background: #f8f9fa;
            padding: 8px;
            text-align: left;
            font-size: 11px;
            text-transform: uppercase;
            color: #666;
            border-bottom: 2px solid #dee2e6;
        }

        .partition-table td {
            padding: 8px;
            font-size: 12px;
            border-bottom: 1px solid #eee;
        }

        .partition-table tr:hover {
            background: #f8f9fa;
        }

        .partition-id {
            font-weight: bold;
            background: #e3f2fd;
            padding: 2px 8px;
            border-radius: 4px;
            display: inline-block;
        }

        .latency-cell {
            font-weight: 500;
            text-align: right;
        }

        .latency-high {
            color: #d32f2f;
            font-weight: bold;
        }

        .latency-medium {
            color: #ff9800;
        }

        .latency-low {
            color: #2e7d32;
        }

        .message-count {
            text-align: right;
            color: #666;
        }

        .no-partition-data {
            padding: 40px;
            text-align: center;
            color: #999;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üöÄ RedPanda Latency Analyzer</h1>
        <div id="dataStatus">‚è≥ Loading bucket_analysis.jsonl...</div>
    </div>

    <div class="file-input-container">
        <label for="fileInput" class="file-label">
            üìÅ Load bucket_analysis.jsonl
        </label>
        <input type="file" id="fileInput" accept=".jsonl">
    </div>

    <div class="controls" style="display:none;" id="controls">
        <div class="control-group">
            <label>Aggregation:</label>
            <select id="aggregation">
                <option value="none">Raw (5-min buckets)</option>
                <option value="hourly">Hourly</option>
                <option value="daily">Daily</option>
                <option value="file">By File</option>
            </select>
        </div>
        <div class="control-group">
            <label>File Filter:</label>
            <select id="fileFilter">
                <option value="">All Files</option>
            </select>
        </div>
        <div class="control-group">
            <label>Partition:</label>
            <select id="partitionFilter">
                <option value="">All Partitions</option>
            </select>
        </div>
        <div class="control-group">
            <label>Time Range:</label>
            <input type="datetime-local" id="startTime">
            <input type="datetime-local" id="endTime">
        </div>
        <div class="control-group">
            <button onclick="applyFilters()">Apply Filters</button>
            <button onclick="exportData()" style="background: #666;">Export CSV</button>
        </div>
    </div>

    <div class="stats-grid" id="statsGrid" style="display:none;">
        <div class="stat-card">
            <div class="stat-title">Total Buckets</div>
            <div class="stat-value" id="totalBuckets">-</div>
        </div>
        <div class="stat-card">
            <div class="stat-title">Total Messages</div>
            <div class="stat-value" id="totalMessages">-</div>
        </div>
        <div class="stat-card">
            <div class="stat-title">Unique Files</div>
            <div class="stat-value" id="uniqueFiles">-</div>
        </div>
        <div class="stat-card">
            <div class="stat-title">Partitions</div>
            <div class="stat-value" id="partitionCount">-</div>
        </div>
    </div>

    <div class="chart-container" id="percentileCard" style="display:none;">
        <h3>Overall Percentiles (ms)</h3>
        <div class="percentile-grid" id="percentileGrid"></div>
    </div>

    <div class="chart-container" id="chartContainer" style="display:none; position: relative;">
        <h3>Latency Trends <span id="chartInfo" style="font-size: 12px; color: #666; font-weight: normal;"></span></h3>
        <div class="chart-scroll-container" id="chartScrollContainer" style="position: relative;">
            <canvas id="latencyChart"></canvas>
        </div>
        <div class="tooltip-bubble" id="tooltipBubble"></div>
        <div style="margin-top: 10px; font-size: 12px; color: #666;">
            <span style="display: inline-block; margin-right: 20px;">
                <span style="display: inline-block; width: 20px; height: 2px; background: #d62728; vertical-align: middle;"></span> P99.99
            </span>
            <span style="display: inline-block; margin-right: 20px;">
                <span style="display: inline-block; width: 20px; height: 2px; background: #ff7f0e; vertical-align: middle;"></span> P99
            </span>
            <span style="display: inline-block; margin-right: 20px;">
                <span style="display: inline-block; width: 20px; height: 2px; background: #2ca02c; vertical-align: middle;"></span> P95
            </span>
            <span style="display: inline-block; margin-right: 20px;">
                <span style="display: inline-block; width: 20px; height: 2px; background: #1f77b4; vertical-align: middle;"></span> P50
            </span>
            <span style="font-style: italic; margin-left: 20px;">
                (Scroll horizontally to see all data ‚Üí)
            </span>
        </div>
    </div>

    <div id="partitionContainer" style="display:none;">
        <div class="partition-header">
            <div>
                <div class="partition-title">üéØ Partition Performance</div>
                <div class="partition-info" id="partitionInfo">Hover over the chart to see partition details</div>
            </div>
        </div>
        <div id="partitionContent">
            <div class="no-partition-data">Hover over a data point in the latency chart to view partition-level statistics</div>
        </div>
    </div>

    <div class="table-container" id="tableContainer" style="display:none;">
        <h3>Detailed Analysis</h3>
        <table id="dataTable">
            <thead>
                <tr>
                    <th>Time</th>
                    <th>File/Group</th>
                    <th>Messages</th>
                    <th>Avg (ms)</th>
                    <th>P50</th>
                    <th>P95</th>
                    <th>P99</th>
                    <th>P99.99</th>
                </tr>
            </thead>
            <tbody id="tableBody"></tbody>
        </table>
    </div>

    <script>
        let allData = [];
        let filteredData = [];
        let uniqueFiles = new Set();
        let uniquePartitions = new Set();
        let currentHoverPoint = null;

        // Auto-load bucket_analysis.jsonl on page load
        window.addEventListener('load', async () => {
            try {
                const response = await fetch('bucket_analysis.jsonl');
                if (response.ok) {
                    const text = await response.text();
                    loadData(text);
                    document.getElementById('fileInput').parentElement.style.display = 'none';
                } else {
                    document.getElementById('dataStatus').innerHTML = 
                        '‚ö†Ô∏è bucket_analysis.jsonl not found - use file selector below to load data';
                }
            } catch (error) {
                // Likely opened as file:// instead of http://
                document.getElementById('dataStatus').innerHTML = 
                    'üìù Note: Run ./serve_analyzer.sh to auto-load data, or select file below';
            }
        });

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => loadData(e.target.result);
                reader.readAsText(file);
            }
        }

        function loadData(text) {
            try {
                allData = text.trim().split('\n')
                    .filter(line => line.trim())
                    .map(line => JSON.parse(line));
                
                // Extract unique values
                allData.forEach(bucket => {
                    uniqueFiles.add(bucket.filename);
                    if (bucket.partition_latency_stats) {
                        bucket.partition_latency_stats.forEach(stat => {
                            uniquePartitions.add(stat.Partition);
                        });
                    }
                });

                // Populate filters
                const fileSelect = document.getElementById('fileFilter');
                fileSelect.innerHTML = '<option value="">All Files</option>';
                Array.from(uniqueFiles).sort().forEach(file => {
                    fileSelect.innerHTML += `<option value="${file}">${file}</option>`;
                });

                const partitionSelect = document.getElementById('partitionFilter');
                partitionSelect.innerHTML = '<option value="">All Partitions</option>';
                Array.from(uniquePartitions).sort((a,b) => a-b).forEach(partition => {
                    partitionSelect.innerHTML += `<option value="${partition}">Partition ${partition}</option>`;
                });

                // Set time range
                if (allData.length > 0) {
                    const times = allData.map(d => new Date(d.start_time));
                    const minTime = new Date(Math.min(...times));
                    const maxTime = new Date(Math.max(...times));
                    
                    document.getElementById('startTime').value = formatDateTime(minTime);
                    document.getElementById('endTime').value = formatDateTime(maxTime);
                }

                document.getElementById('dataStatus').innerHTML = 
                    `‚úÖ Loaded ${allData.length} buckets from ${uniqueFiles.size} files with ${uniquePartitions.size} partitions`;
                
                // Show controls and apply initial filters
                document.getElementById('controls').style.display = 'block';
                document.getElementById('statsGrid').style.display = 'grid';
                document.getElementById('percentileCard').style.display = 'block';
                document.getElementById('chartContainer').style.display = 'block';
                document.getElementById('partitionContainer').style.display = 'block';
                document.getElementById('tableContainer').style.display = 'block';
                
                applyFilters();
                
            } catch (error) {
                alert('Error loading data: ' + error.message);
            }
        }

        function formatDateTime(date) {
            const d = new Date(date);
            return d.getFullYear() + '-' + 
                   String(d.getMonth() + 1).padStart(2, '0') + '-' +
                   String(d.getDate()).padStart(2, '0') + 'T' +
                   String(d.getHours()).padStart(2, '0') + ':' +
                   String(d.getMinutes()).padStart(2, '0');
        }

        function applyFilters() {
            const fileFilter = document.getElementById('fileFilter').value;
            const partitionFilter = document.getElementById('partitionFilter').value;
            const startTime = new Date(document.getElementById('startTime').value);
            const endTime = new Date(document.getElementById('endTime').value);
            
            filteredData = allData.filter(bucket => {
                const bucketTime = new Date(bucket.start_time);
                
                if (fileFilter && bucket.filename !== fileFilter) return false;
                if (bucketTime < startTime || bucketTime > endTime) return false;
                
                if (partitionFilter) {
                    const hasPartition = bucket.partition_latency_stats?.some(
                        stat => stat.Partition == partitionFilter
                    );
                    if (!hasPartition) return false;
                }
                
                return true;
            });
            
            updateDisplay();
        }

        function updateDisplay() {
            const aggregation = document.getElementById('aggregation').value;
            let displayData = filteredData;
            
            if (aggregation === 'hourly') {
                displayData = aggregateByHour(filteredData);
            } else if (aggregation === 'daily') {
                displayData = aggregateByDay(filteredData);
            } else if (aggregation === 'file') {
                displayData = aggregateByFile(filteredData);
            }
            
            updateStats(displayData);
            updatePercentiles(displayData);
            updateChart(displayData);
            updateTable(displayData);
        }

        function aggregateByHour(data) {
            const hourlyData = {};
            
            data.forEach(bucket => {
                const date = new Date(bucket.start_time);
                const hourKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:00`;
                
                if (!hourlyData[hourKey]) {
                    hourlyData[hourKey] = {
                        start_time: hourKey,
                        buckets: [],
                        total_messages: 0,
                        latencies: []
                    };
                }
                
                hourlyData[hourKey].buckets.push(bucket);
                hourlyData[hourKey].total_messages += bucket.total_messages;
                hourlyData[hourKey].latencies.push(bucket.overall_p99_99_ms);
            });
            
            return Object.values(hourlyData).map(hour => ({
                ...hour,
                overall_p99_99_ms: Math.max(...hour.latencies),
                overall_p99_ms: percentile(hour.latencies, 99),
                overall_p95_ms: percentile(hour.latencies, 95),
                overall_p50_ms: percentile(hour.latencies, 50),
                overall_avg_ms: hour.latencies.reduce((a,b) => a+b, 0) / hour.latencies.length,
                bucket_count: hour.buckets.length
            }));
        }

        function aggregateByDay(data) {
            const dailyData = {};
            
            data.forEach(bucket => {
                const date = new Date(bucket.start_time);
                const dayKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')}`;
                
                if (!dailyData[dayKey]) {
                    dailyData[dayKey] = {
                        start_time: dayKey,
                        buckets: [],
                        total_messages: 0,
                        latencies: []
                    };
                }
                
                dailyData[dayKey].buckets.push(bucket);
                dailyData[dayKey].total_messages += bucket.total_messages;
                dailyData[dayKey].latencies.push(bucket.overall_p99_99_ms);
            });
            
            return Object.values(dailyData).map(day => ({
                ...day,
                overall_p99_99_ms: Math.max(...day.latencies),
                overall_p99_ms: percentile(day.latencies, 99),
                overall_p95_ms: percentile(day.latencies, 95),
                overall_p50_ms: percentile(day.latencies, 50),
                overall_avg_ms: day.latencies.reduce((a,b) => a+b, 0) / day.latencies.length,
                bucket_count: day.buckets.length
            }));
        }

        function aggregateByFile(data) {
            const fileData = {};
            
            data.forEach(bucket => {
                if (!fileData[bucket.filename]) {
                    fileData[bucket.filename] = {
                        filename: bucket.filename,
                        start_time: bucket.start_time,
                        buckets: [],
                        total_messages: 0,
                        latencies: []
                    };
                }
                
                fileData[bucket.filename].buckets.push(bucket);
                fileData[bucket.filename].total_messages += bucket.total_messages;
                fileData[bucket.filename].latencies.push(bucket.overall_p99_99_ms);
            });
            
            return Object.values(fileData).map(file => ({
                ...file,
                overall_p99_99_ms: Math.max(...file.latencies),
                overall_p99_ms: percentile(file.latencies, 99),
                overall_p95_ms: percentile(file.latencies, 95),
                overall_p50_ms: percentile(file.latencies, 50),
                overall_avg_ms: file.latencies.reduce((a,b) => a+b, 0) / file.latencies.length,
                bucket_count: file.buckets.length
            }));
        }

        function percentile(arr, p) {
            const sorted = [...arr].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function updateStats(data) {
            const totalMessages = data.reduce((sum, d) => sum + d.total_messages, 0);
            const filesInView = new Set(data.map(d => d.filename)).size || uniqueFiles.size;
            
            document.getElementById('totalBuckets').textContent = data.length;
            document.getElementById('totalMessages').textContent = totalMessages.toLocaleString();
            document.getElementById('uniqueFiles').textContent = filesInView;
            document.getElementById('partitionCount').textContent = uniquePartitions.size;
        }

        function updatePercentiles(data) {
            if (data.length === 0) return;
            
            const allLatencies = {
                p50: data.map(d => d.overall_p50_ms || 0),
                p95: data.map(d => d.overall_p95_ms || 0),
                p99: data.map(d => d.overall_p99_ms || 0),
                p9999: data.map(d => d.overall_p99_99_ms || 0)
            };
            
            const grid = document.getElementById('percentileGrid');
            grid.innerHTML = `
                <div class="percentile-item">
                    <div class="percentile-label">P50</div>
                    <div class="percentile-value p50">${percentile(allLatencies.p50, 50).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">P95</div>
                    <div class="percentile-value p95">${percentile(allLatencies.p95, 50).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">P99</div>
                    <div class="percentile-value p99">${percentile(allLatencies.p99, 50).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">P99.99</div>
                    <div class="percentile-value p9999">${percentile(allLatencies.p9999, 50).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">Max P50</div>
                    <div class="percentile-value p50">${Math.max(...allLatencies.p50).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">Max P95</div>
                    <div class="percentile-value p95">${Math.max(...allLatencies.p95).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">Max P99</div>
                    <div class="percentile-value p99">${Math.max(...allLatencies.p99).toFixed(2)}</div>
                </div>
                <div class="percentile-item">
                    <div class="percentile-label">Max P99.99</div>
                    <div class="percentile-value p9999">${Math.max(...allLatencies.p9999).toFixed(2)}</div>
                </div>
            `;
        }

        function updateChart(data) {
            const canvas = document.getElementById('latencyChart');
            const ctx = canvas.getContext('2d');
            
            if (data.length === 0) {
                canvas.width = 800;
                canvas.height = 300;
                return;
            }
            
            // Calculate canvas width based on data points
            // Minimum 3 pixels per point, but at least screen width
            const pointWidth = Math.max(3, 800 / data.length);
            const chartWidth = Math.max(800, data.length * pointWidth);
            
            // Set canvas dimensions
            canvas.width = chartWidth;
            canvas.height = 300;
            
            // Update info
            document.getElementById('chartInfo').textContent = 
                `(${data.length} data points${data.length > 200 ? ' - scroll to see all' : ''})`;
            
            // Chart dimensions
            const padding = { top: 40, right: 40, bottom: 40, left: 60 };
            const width = chartWidth - padding.left - padding.right;
            const height = 300 - padding.top - padding.bottom;
            
            // Fixed Y-axis at 100ms
            const maxLatency = 100;
            
            // Clear and setup canvas
            ctx.clearRect(0, 0, chartWidth, 300);
            
            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;
            
            // Horizontal grid lines
            for (let i = 0; i <= 5; i++) {
                const y = padding.top + (i * height / 5);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(chartWidth - padding.right, y);
                ctx.stroke();
                
                // Y-axis labels
                ctx.fillStyle = '#666';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'right';
                const value = maxLatency * (1 - i / 5);
                ctx.fillText(value.toFixed(0) + 'ms', padding.left - 5, y + 4);
            }
            
            // Vertical grid lines (time-based)
            const gridStep = Math.max(1, Math.floor(data.length / 20));
            for (let i = 0; i < data.length; i += gridStep) {
                const x = padding.left + (i / (data.length - 1)) * width;
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                ctx.beginPath();
                ctx.moveTo(x, padding.top);
                ctx.lineTo(x, padding.top + height);
                ctx.stroke();
                
                // Time labels
                if (i % (gridStep * 2) === 0) {
                    ctx.fillStyle = '#666';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    const time = new Date(data[i].start_time);
                    const label = data.length > 100 ? 
                        `${time.getMonth()+1}/${time.getDate()} ${time.getHours()}:${String(time.getMinutes()).padStart(2,'0')}` :
                        `${time.getHours()}:${String(time.getMinutes()).padStart(2,'0')}`;
                    ctx.fillText(label, x, padding.top + height + 20);
                }
            }
            
            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, padding.top + height);
            ctx.lineTo(chartWidth - padding.right, padding.top + height);
            ctx.stroke();
            
            // Draw data lines
            const metrics = [
                {key: 'overall_p50_ms', color: '#1f77b4', width: 1.5},
                {key: 'overall_p95_ms', color: '#2ca02c', width: 1.5},
                {key: 'overall_p99_ms', color: '#ff7f0e', width: 2},
                {key: 'overall_p99_99_ms', color: '#d62728', width: 2.5}
            ];
            
            metrics.forEach(metric => {
                ctx.strokeStyle = metric.color;
                ctx.lineWidth = metric.width;
                ctx.beginPath();
                
                let hasData = false;
                data.forEach((point, i) => {
                    const value = point[metric.key] || 0;
                    const x = padding.left + (i / (data.length - 1)) * width;
                    // Clamp values to maxLatency (100ms)
                    const clampedValue = Math.min(value, maxLatency);
                    const y = padding.top + height - (clampedValue / maxLatency) * height;

                    if (i === 0 || !hasData) {
                        ctx.moveTo(x, y);
                        hasData = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                if (hasData) ctx.stroke();
            });
            
            // Enhanced hover interaction with tooltip bubble
            setupHoverInteraction(canvas, data, padding, width, height);
        }

        function updateTable(data) {
            const tbody = document.getElementById('tableBody');
            const aggregation = document.getElementById('aggregation').value;
            
            // Limit table rows for performance
            const maxRows = 100;
            const displayData = data.slice(0, maxRows);
            
            tbody.innerHTML = displayData.map(row => {
                const identifier = row.filename || row.start_time;
                const time = aggregation === 'file' ? 
                    `${row.bucket_count} buckets` : 
                    new Date(row.start_time).toLocaleString();
                
                return `
                    <tr>
                        <td>${time}</td>
                        <td>${identifier}</td>
                        <td>${row.total_messages?.toLocaleString() || '-'}</td>
                        <td>${(row.overall_avg_ms || 0).toFixed(2)}</td>
                        <td>${(row.overall_p50_ms || 0).toFixed(2)}</td>
                        <td>${(row.overall_p95_ms || 0).toFixed(2)}</td>
                        <td>${(row.overall_p99_ms || 0).toFixed(2)}</td>
                        <td>${(row.overall_p99_99_ms || 0).toFixed(2)}</td>
                    </tr>
                `;
            }).join('');
            
            if (data.length > maxRows) {
                tbody.innerHTML += `
                    <tr>
                        <td colspan="8" style="text-align: center; color: #666;">
                            ... showing first ${maxRows} of ${data.length} rows ...
                        </td>
                    </tr>
                `;
            }
        }

        function exportData() {
            const aggregation = document.getElementById('aggregation').value;
            const data = filteredData;
            
            let csv = 'Time,File,Messages,Avg_ms,P50_ms,P95_ms,P99_ms,P99.99_ms\n';
            
            data.forEach(row => {
                csv += `${row.start_time},${row.filename},${row.total_messages},`;
                csv += `${row.overall_avg_ms},${row.overall_p50_ms},${row.overall_p95_ms},`;
                csv += `${row.overall_p99_ms},${row.overall_p99_99_ms}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `latency_analysis_${aggregation}_${Date.now()}.csv`;
            a.click();
        }

        function setupHoverInteraction(canvas, data, padding, width, height) {
            const tooltip = document.getElementById('tooltipBubble');
            const scrollContainer = document.getElementById('chartScrollContainer');
            const chartContainer = document.getElementById('chartContainer');

            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scrollRect = scrollContainer.getBoundingClientRect();
                const chartRect = chartContainer.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const dataIndex = Math.round((x - padding.left) / width * (data.length - 1));

                if (dataIndex >= 0 && dataIndex < data.length &&
                    x >= padding.left && x <= padding.left + width &&
                    y >= padding.top && y <= padding.top + height) {

                    const point = data[dataIndex];
                    const time = new Date(point.start_time);

                    // Update tooltip content
                    tooltip.innerHTML = `
                        <div class="tooltip-header">
                            üìä ${time.toLocaleString()}
                            ${point.filename ? `<br><small style="color: #666;">${point.filename}</small>` : ''}
                        </div>
                        <div class="tooltip-stats">
                            <div class="tooltip-stat">
                                <span class="tooltip-label">P50</span>
                                <span class="tooltip-value p50">${(point.overall_p50_ms || 0).toFixed(2)}ms</span>
                            </div>
                            <div class="tooltip-stat">
                                <span class="tooltip-label">P95</span>
                                <span class="tooltip-value p95">${(point.overall_p95_ms || 0).toFixed(2)}ms</span>
                            </div>
                            <div class="tooltip-stat">
                                <span class="tooltip-label">P99</span>
                                <span class="tooltip-value p99">${(point.overall_p99_ms || 0).toFixed(2)}ms</span>
                            </div>
                            <div class="tooltip-stat">
                                <span class="tooltip-label">P99.9</span>
                                <span class="tooltip-value p999">${(point.overall_p99_9_ms || point.overall_p999_ms || 0).toFixed(2)}ms</span>
                            </div>
                            <div class="tooltip-stat">
                                <span class="tooltip-label">P99.99</span>
                                <span class="tooltip-value p9999">${(point.overall_p99_99_ms || 0).toFixed(2)}ms</span>
                            </div>
                        </div>
                        <div class="tooltip-messages">
                            <strong>${(point.total_messages || 0).toLocaleString()}</strong> messages
                            ${point.bucket_count ? `<br>${point.bucket_count} buckets` : ''}
                        </div>
                    `;

                    // Position tooltip relative to chart container, accounting for scroll
                    const scrollLeft = scrollContainer.scrollLeft;
                    const mouseXInContainer = e.clientX - chartRect.left;
                    const mouseYInContainer = e.clientY - chartRect.top;

                    // Calculate tooltip position
                    let tooltipX = mouseXInContainer + 15;
                    let tooltipY = mouseYInContainer - 80;

                    // Keep tooltip within chart container bounds
                    const tooltipWidth = 300; // approximate width
                    const tooltipHeight = 200; // approximate height

                    // Adjust horizontal position if too close to edges
                    if (tooltipX + tooltipWidth > chartRect.width) {
                        tooltipX = mouseXInContainer - tooltipWidth - 15;
                    }
                    if (tooltipX < 0) {
                        tooltipX = 10;
                    }

                    // Adjust vertical position
                    if (tooltipY < 10) {
                        tooltipY = mouseYInContainer + 20;
                    }
                    if (tooltipY + tooltipHeight > chartRect.height) {
                        tooltipY = chartRect.height - tooltipHeight - 10;
                    }

                    tooltip.style.display = 'block';
                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';

                    // Update partition display
                    updatePartitionDisplay(point);
                    currentHoverPoint = point;

                } else {
                    tooltip.style.display = 'none';
                    currentHoverPoint = null;
                }
            };

            canvas.onmouseleave = () => {
                tooltip.style.display = 'none';
                // Clear partition display
                const partitionContent = document.getElementById('partitionContent');
                if (partitionContent && !currentHoverPoint) {
                    partitionContent.innerHTML = '<div class="no-partition-data">Hover over a data point in the latency chart to view partition-level statistics</div>';
                }
            };

            // Fix for stuck tooltip on fast mouse movements
            scrollContainer.onmouseleave = () => {
                tooltip.style.display = 'none';
            };

            chartContainer.onmouseleave = () => {
                tooltip.style.display = 'none';
            };
        }

        function updatePartitionDisplay(point) {
            const container = document.getElementById('partitionContent');
            const info = document.getElementById('partitionInfo');

            if (!point || !point.partition_latency_stats || point.partition_latency_stats.length === 0) {
                container.innerHTML = '<div class="no-partition-data">No partition data available for this time period</div>';
                info.textContent = 'No partition data available';
                return;
            }

            const time = new Date(point.start_time);
            info.innerHTML = `<strong>${time.toLocaleString()}</strong> - ${point.partition_latency_stats.length} partitions, ${(point.total_messages || 0).toLocaleString()} messages`;

            // Sort partitions by P99.99 descending (most critical metric)
            const sortedPartitions = [...point.partition_latency_stats].sort((a, b) =>
                (b.P9999 || b.P99_99 || b.P99 || 0) - (a.P9999 || a.P99_99 || a.P99 || 0)
            );

            // Create table
            const tableHtml = `
                <table class="partition-table">
                    <thead>
                        <tr>
                            <th>Partition</th>
                            <th style="text-align: right;">P50</th>
                            <th style="text-align: right;">P95</th>
                            <th style="text-align: right;">P99</th>
                            <th style="text-align: right;">P99.9</th>
                            <th style="text-align: right;">P99.99</th>
                            <th style="text-align: right;">Messages</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${sortedPartitions.map(stat => {
                            const p99 = stat.P99 || 0;
                            const p999 = stat.P999 || stat.P99_9 || 0;
                            const p9999 = stat.P9999 || stat.P99_99 || 0;

                            // Color coding based on P99.99
                            const p9999Class = p9999 > 100 ? 'latency-high' : (p9999 > 50 ? 'latency-medium' : 'latency-low');
                            const p999Class = p999 > 100 ? 'latency-high' : (p999 > 50 ? 'latency-medium' : 'latency-low');
                            const p99Class = p99 > 100 ? 'latency-high' : (p99 > 50 ? 'latency-medium' : 'latency-low');

                            return `
                                <tr>
                                    <td><span class="partition-id">P${stat.Partition}</span></td>
                                    <td class="latency-cell">${(stat.P50 || 0).toFixed(2)}</td>
                                    <td class="latency-cell">${(stat.P95 || 0).toFixed(2)}</td>
                                    <td class="latency-cell ${p99Class}">${p99.toFixed(2)}</td>
                                    <td class="latency-cell ${p999Class}">${p999.toFixed(2)}</td>
                                    <td class="latency-cell ${p9999Class}">${p9999.toFixed(2)}</td>
                                    <td class="message-count">${(stat.MessageCount || 0).toLocaleString()}</td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            `;

            container.innerHTML = tableHtml;
        }
    </script>
</body>
</html>

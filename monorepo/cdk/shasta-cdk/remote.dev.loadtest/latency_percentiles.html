<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latency Percentile Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        .file-input-wrapper {
            text-align: center;
            margin-bottom: 30px;
        }

        .file-label {
            display: inline-block;
            padding: 12px 30px;
            background: white;
            color: #667eea;
            border-radius: 30px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            transition: transform 0.3s;
        }

        .file-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.25);
        }

        #fileInput {
            display: none;
        }

        .status {
            color: white;
            text-align: center;
            margin: 20px 0;
            font-size: 1.1rem;
        }


        .chart-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            margin-bottom: 30px;
            position: relative;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 700;
            color: #333;
            margin-bottom: 25px;
        }

        .chart-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .tab-button {
            padding: 8px 20px;
            background: #f0f0f0;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .tab-button.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .chart-scroll-container {
            overflow-x: auto;
            overflow-y: hidden;
            max-width: 100%;
            padding-bottom: 10px;
            position: relative;
        }

        .chart-scroll-container::-webkit-scrollbar {
            height: 10px;
        }

        .chart-scroll-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .chart-scroll-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 10px;
        }

        .chart-scroll-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #5a67d8, #6b46a0);
        }

        canvas {
            height: 600px;
            display: block;
        }

        .tooltip-bubble {
            position: absolute;
            background: white;
            border: 2px solid #667eea;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            pointer-events: none;
            z-index: 1000;
            min-width: 250px;
            display: none;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-5px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .tooltip-header {
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
        }

        .tooltip-stat {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
        }

        .tooltip-label {
            font-size: 12px;
            color: #666;
        }

        .tooltip-value {
            font-weight: bold;
            font-size: 13px;
        }

        .tooltip-value.p50 { color: #4CAF50; }
        .tooltip-value.p99 { color: #FF9800; }
        .tooltip-value.p999 { color: #f44336; }
        .tooltip-value.p9999 { color: #9C27B0; }

        .summary-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .summary-item {
            text-align: center;
        }

        .summary-label {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 8px;
        }

        .summary-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #333;
        }

        .loading {
            text-align: center;
            color: white;
            font-size: 1.2rem;
            padding: 40px;
        }

        .hidden {
            display: none;
        }

        @media (max-width: 768px) {
            .summary-stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Latency Percentile Analysis</h1>

        <div class="file-input-wrapper">
            <label for="fileInput" class="file-label">
                üìÅ Load bucket_analysis.jsonl
            </label>
            <input type="file" id="fileInput" accept=".jsonl">
        </div>

        <div class="status" id="status">Loading data...</div>

        <div id="mainContent" class="hidden">
            <div class="summary-stats">
                <div class="summary-item">
                    <div class="summary-label">Total Samples</div>
                    <div class="summary-value" id="totalSamples">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">5-min Buckets</div>
                    <div class="summary-value" id="fiveMinBuckets">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">1-hour Buckets</div>
                    <div class="summary-value" id="oneHourBuckets">-</div>
                </div>
                <div class="summary-item">
                    <div class="summary-label">Time Range</div>
                    <div class="summary-value" id="timeRange" style="font-size: 1rem;">-</div>
                </div>
            </div>

            <div class="chart-card">
                <div class="card-title">Latency Trends</div>
                <div class="chart-tabs">
                    <button class="tab-button active" onclick="switchChart('5min')">5-Minute Buckets</button>
                    <button class="tab-button" onclick="switchChart('1hour')">1-Hour Buckets</button>
                </div>
                <div class="chart-scroll-container" id="chartScrollContainer">
                    <canvas id="latencyChart"></canvas>
                </div>
                <div class="tooltip-bubble" id="tooltipBubble"></div>
            </div>
        </div>
    </div>

    <script>
        let rawData = [];
        let hourlyData = [];
        let currentView = '5min';

        // Auto-load data on page load
        window.addEventListener('load', async () => {
            try {
                const response = await fetch('bucket_analysis.jsonl');
                if (response.ok) {
                    const text = await response.text();
                    loadData(text);
                    document.querySelector('.file-input-wrapper').style.display = 'none';
                } else {
                    document.getElementById('status').textContent = 'Please select bucket_analysis.jsonl file';
                }
            } catch (error) {
                document.getElementById('status').textContent = 'Please select bucket_analysis.jsonl file';
            }
        });

        document.getElementById('fileInput').addEventListener('change', handleFileSelect);

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => loadData(e.target.result);
                reader.readAsText(file);
            }
        }

        function loadData(text) {
            try {
                // Parse JSONL data
                rawData = text.trim().split('\n')
                    .filter(line => line.trim())
                    .map(line => JSON.parse(line))
                    .sort((a, b) => new Date(a.start_time) - new Date(b.start_time));

                // Create hourly aggregations
                hourlyData = aggregateToHourly(rawData);

                // Update UI
                updateStatistics();
                drawChart();

                document.getElementById('status').style.display = 'none';
                document.getElementById('mainContent').classList.remove('hidden');

            } catch (error) {
                document.getElementById('status').textContent = 'Error loading data: ' + error.message;
            }
        }

        function aggregateToHourly(data) {
            const hourlyMap = {};

            data.forEach(bucket => {
                const date = new Date(bucket.start_time);
                const hourKey = `${date.getFullYear()}-${String(date.getMonth()+1).padStart(2,'0')}-${String(date.getDate()).padStart(2,'0')} ${String(date.getHours()).padStart(2,'0')}:00`;

                if (!hourlyMap[hourKey]) {
                    hourlyMap[hourKey] = {
                        start_time: hourKey,
                        p50_values: [],
                        p99_values: [],
                        p999_values: [],
                        p9999_values: [],
                        total_messages: 0
                    };
                }

                hourlyMap[hourKey].p50_values.push(bucket.overall_p50_ms || 0);
                hourlyMap[hourKey].p99_values.push(bucket.overall_p99_ms || 0);
                hourlyMap[hourKey].p999_values.push(bucket.overall_p99_9_ms || 0);
                hourlyMap[hourKey].p9999_values.push(bucket.overall_p99_99_ms || 0);
                hourlyMap[hourKey].total_messages += bucket.total_messages || 0;
            });

            // Calculate percentiles for each hour
            return Object.values(hourlyMap).map(hour => ({
                start_time: hour.start_time,
                overall_p50_ms: percentile(hour.p50_values, 50),
                overall_p99_ms: percentile(hour.p99_values, 50),
                overall_p99_9_ms: percentile(hour.p999_values, 50),
                overall_p99_99_ms: percentile(hour.p9999_values, 50),
                total_messages: hour.total_messages
            })).sort((a, b) => new Date(a.start_time) - new Date(b.start_time));
        }

        function percentile(arr, p) {
            const sorted = [...arr].sort((a, b) => a - b);
            const index = (p / 100) * (sorted.length - 1);
            const lower = Math.floor(index);
            const upper = Math.ceil(index);
            const weight = index - lower;
            return sorted[lower] * (1 - weight) + sorted[upper] * weight;
        }

        function updateStatistics() {
            // Update summary
            const totalMessages = rawData.reduce((sum, d) => sum + (d.total_messages || 0), 0);
            document.getElementById('totalSamples').textContent = totalMessages.toLocaleString();
            document.getElementById('fiveMinBuckets').textContent = rawData.length.toLocaleString();
            document.getElementById('oneHourBuckets').textContent = hourlyData.length.toLocaleString();

            // Time range
            if (rawData.length > 0) {
                const start = new Date(rawData[0].start_time);
                const end = new Date(rawData[rawData.length - 1].start_time);
                document.getElementById('timeRange').textContent =
                    `${start.toLocaleDateString()} - ${end.toLocaleDateString()}`;
            }
        }

        function switchChart(view) {
            currentView = view;

            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            drawChart();
        }

        function drawChart() {
            const canvas = document.getElementById('latencyChart');
            const ctx = canvas.getContext('2d');
            const scrollContainer = document.getElementById('chartScrollContainer');

            const data = currentView === '5min' ? rawData : hourlyData;

            if (data.length === 0) return;

            // Calculate canvas width based on data points
            // At least 10 pixels per point, minimum 1200px width
            const pointWidth = Math.max(10, 1200 / data.length);
            const chartWidth = Math.max(1200, data.length * pointWidth);

            // Set canvas size
            canvas.width = chartWidth;
            canvas.height = 600;

            const width = chartWidth;
            const height = 600;
            const padding = { top: 40, right: 80, bottom: 60, left: 80 };
            const plotWidth = width - padding.left - padding.right;
            const plotHeight = height - padding.top - padding.bottom;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Fixed Y-axis scale at 500ms
            const maxValue = 500;

            // Draw grid lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 0.5;

            // Horizontal grid lines (more lines for taller chart)
            for (let i = 0; i <= 8; i++) {
                const y = padding.top + (i * plotHeight / 8);
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(width - padding.right, y);
                ctx.stroke();

                // Y-axis labels
                ctx.fillStyle = '#666';
                ctx.font = '12px sans-serif';
                ctx.textAlign = 'right';
                const value = maxValue * (1 - i / 8);
                ctx.fillText(value.toFixed(0) + 'ms', padding.left - 10, y + 4);
            }

            // Add Y-axis label
            ctx.save();
            ctx.fillStyle = '#333';
            ctx.font = 'bold 12px sans-serif';
            ctx.translate(20, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Latency (ms) - Scale: 0-500ms', 0, 0);
            ctx.restore();

            // Draw axes
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding.left, padding.top);
            ctx.lineTo(padding.left, height - padding.bottom);
            ctx.lineTo(width - padding.right, height - padding.bottom);
            ctx.stroke();

            // Store data points for hover interaction
            const dataPoints = [];

            // Draw data lines
            const metrics = [
                {key: 'overall_p50_ms', color: '#4CAF50', width: 2, label: 'P50'},
                {key: 'overall_p99_ms', color: '#FF9800', width: 2, label: 'P99'},
                {key: 'overall_p99_9_ms', color: '#f44336', width: 2, label: 'P99.9'},
                {key: 'overall_p99_99_ms', color: '#9C27B0', width: 2.5, label: 'P99.99'}
            ];

            // Draw lines
            metrics.forEach(metric => {
                ctx.strokeStyle = metric.color;
                ctx.lineWidth = metric.width;
                ctx.beginPath();

                let hasClippedValues = false;
                data.forEach((point, i) => {
                    const value = point[metric.key] || 0;
                    const x = padding.left + (i / (data.length - 1)) * plotWidth;
                    // Clamp values to maxValue for display
                    const clampedValue = Math.min(value, maxValue);
                    const y = height - padding.bottom - (clampedValue / maxValue) * plotHeight;

                    if (value > maxValue) hasClippedValues = true;

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }

                    // Store point data for hover (with original value)
                    if (metric.key === 'overall_p50_ms') {
                        dataPoints[i] = { x, data: point };
                    }
                });

                ctx.stroke();

                // Draw indicators for clipped values
                if (hasClippedValues) {
                    ctx.fillStyle = metric.color;
                    data.forEach((point, i) => {
                        const value = point[metric.key] || 0;
                        if (value > maxValue) {
                            const x = padding.left + (i / (data.length - 1)) * plotWidth;
                            const y = padding.top;
                            // Draw a small triangle at top to indicate clipped value
                            ctx.beginPath();
                            ctx.moveTo(x, y - 5);
                            ctx.lineTo(x - 3, y);
                            ctx.lineTo(x + 3, y);
                            ctx.closePath();
                            ctx.fill();
                        }
                    });
                }
            });

            // Draw X-axis labels
            const step = Math.max(1, Math.floor(data.length / 20));
            ctx.fillStyle = '#666';
            ctx.font = '11px sans-serif';
            ctx.textAlign = 'center';

            for (let i = 0; i < data.length; i += step) {
                const x = padding.left + (i / (data.length - 1)) * plotWidth;
                const date = new Date(data[i].start_time);
                const label = currentView === '5min'
                    ? `${date.getHours()}:${String(date.getMinutes()).padStart(2,'0')}`
                    : `${date.getMonth()+1}/${date.getDate()} ${date.getHours()}:00`;

                ctx.save();
                ctx.translate(x, height - padding.bottom + 20);
                ctx.rotate(-Math.PI/4);
                ctx.fillText(label, 0, 0);
                ctx.restore();
            }

            // Add legend for clipped values indicator
            const hasAnyClipped = data.some(point =>
                point.overall_p99_99_ms > maxValue ||
                point.overall_p99_9_ms > maxValue ||
                point.overall_p99_ms > maxValue
            );

            if (hasAnyClipped) {
                ctx.fillStyle = '#d32f2f';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'left';
                ctx.fillText('‚ñ≤ = Values exceed 500ms', width - padding.right - 150, padding.top - 10);
            }

            // Setup hover interaction
            setupHoverInteraction(canvas, dataPoints, scrollContainer);
        }

        function setupHoverInteraction(canvas, dataPoints, scrollContainer) {
            const tooltip = document.getElementById('tooltipBubble');
            const chartCard = document.querySelector('.chart-card');

            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;

                // Find closest data point
                let closestPoint = null;
                let closestDist = Infinity;

                dataPoints.forEach(point => {
                    const dist = Math.abs(point.x - x);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestPoint = point;
                    }
                });

                if (closestPoint && closestDist < 20) {
                    const data = closestPoint.data;
                    const date = new Date(data.start_time);

                    // Update tooltip content with all percentiles
                    tooltip.innerHTML = `
                        <div class="tooltip-header">
                            ${date.toLocaleString()}
                            ${data.total_messages ? `<br>${data.total_messages.toLocaleString()} messages (all partitions)` : ''}
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">P50:</span>
                            <span class="tooltip-value p50">${(data.overall_p50_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">P90:</span>
                            <span class="tooltip-value">${(data.overall_p90_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">P95:</span>
                            <span class="tooltip-value">${(data.overall_p95_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">P99:</span>
                            <span class="tooltip-value p99">${(data.overall_p99_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">P99.9:</span>
                            <span class="tooltip-value p999">${(data.overall_p99_9_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">P99.99:</span>
                            <span class="tooltip-value p9999">${(data.overall_p99_99_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div class="tooltip-stat">
                            <span class="tooltip-label">Average:</span>
                            <span class="tooltip-value">${(data.overall_avg_ms || 0).toFixed(2)} ms</span>
                        </div>
                        <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0; font-size: 10px; color: #888; text-align: center;">
                            Percentiles computed across all partitions
                        </div>
                    `;

                    // Position tooltip relative to chart card
                    const chartRect = chartCard.getBoundingClientRect();
                    const scrollLeft = scrollContainer.scrollLeft;

                    let tooltipX = e.clientX - chartRect.left + 15;
                    let tooltipY = e.clientY - chartRect.top - 80;

                    // Keep tooltip within bounds
                    if (tooltipX + 280 > chartRect.width) {
                        tooltipX = e.clientX - chartRect.left - 280;
                    }
                    if (tooltipY < 10) {
                        tooltipY = e.clientY - chartRect.top + 20;
                    }

                    tooltip.style.display = 'block';
                    tooltip.style.left = tooltipX + 'px';
                    tooltip.style.top = tooltipY + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            };

            canvas.onmouseleave = () => {
                tooltip.style.display = 'none';
            };

            scrollContainer.onmouseleave = () => {
                tooltip.style.display = 'none';
            };
        }
    </script>
</body>
</html>